шифр виженера (полиалфавитной замены)

дальнейшим продолжением шифров простой замены является многоалфавитные шифры. абу аль-кинди в своих работах показал, что обычные моноалфавитные шифры довольно-таки просто поддаются частотному криптоанализу и первым предложил использовать многоалфавитные шифры. в европе такие шифры были впервые описаны в 1467 году итальянским архитектором леон баттиста альберти. в xvi веке немецкий аббат иоганн тритемий в своей книге “стенография” представил схему полиалфавитного шифрования в виде таблицы. более сложный вариант с использованием смешанных алфавитов был описан в 1563 году джамбаттиста делла порта в его книге “про скрытую значимость отдельных букв”. последним словом в развитии полиалфавитных шифров можно считать роторные машины, примером которой можно считать немецкую машину enigma, разработанная в 1917 г. суть полиалфавитных шифров заключена в многократном применении различных шифров простой замены к определенному числу букв шифруемого текста. то есть к каждой букве по отдельности применяется один из шифров простой замены.

шифр виженера состоит из последовательности нескольких шифров цезаря с различными значениями сдвига. для зашифровывания может использоваться таблица алфавитов, называемая квадрат (таблица) виженера. применительно к русскому алфавиту таблица виженера составляется из строк по 33 символов, причём каждая следующая строка сдвигается на несколько позиций. таким образом, в таблице получается 33 различных шифров цезаря. на разных этапах кодировки шифр виженера использует различные алфавиты из этой таблицы. на каждом этапе шифрования используются различные алфавиты, выбираемые в зависимости от символа ключевого слова. например, если ключевое слово “сат”, то первая буква открытого текста шифруется с использованием алфавита “с’, вторая “а”, третья “т”, четвёртая снова “с” и так далее.

программа шифрования шифром виженера:

__author__ = 'timofey khirianov'
# -*- coding: utf8 -*-

class vigenere:
    alphabet = ""  # fixme

    def __init__(self, keyword):
        self.alphaindex = {ch: index for index, ch in enumerate(self.alphabet)}
        self.key = [self.alphaindex[letter] for letter in keyword.lower()]

    def caesar(self, letter, shift):
        if letter in self.alphaindex:  # строчная буква
            index = (self.alphaindex[letter] + shift)%len(self.alphabet)
            cipherletter = self.alphabet[index]
        elif letter.lower() in self.alphaindex:  # заглавная буква
            cipherletter = self.caesar(letter.lower(), shift).upper()
        else:
            cipherletter = letter
        return cipherletter

    def encode(self, line):
        ciphertext = []
        for i, letter in enumerate(line):
            shift = self.key[i % len(self.key)]
            cipherletter = self.caesar(letter, shift)
            ciphertext.append(cipherletter)

        return ''.join(ciphertext)

    def decode(self, line):
        pass  # fixme


keyword = input('keyword=')
cipher = vigenere(keyword)

line = input()
while line != '.':
    print(cipher.decode(line))
    line = input()
последний раздел работы зашифрован шифром виженера с неизвестным кодовым словом. подсказка для самых стойких криптоаналитиков: длина кодового слова 8.
